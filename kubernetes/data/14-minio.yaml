---
# MinIO Persistent Volume
apiVersion: v1
kind: PersistentVolume
metadata:
  name: minio-pv
spec:
  capacity:
    storage: 20Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: standard
  hostPath:
    path: /tmp/minio-data
---
# MinIO Persistent Volume Claim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: minio-pvc
  namespace: production
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
  storageClassName: standard
---
# MinIO StatefulSet
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: minio
  namespace: production
  labels:
    app: minio
    component: storage
spec:
  serviceName: minio
  replicas: 1
  selector:
    matchLabels:
      app: minio
  template:
    metadata:
      labels:
        app: minio
        component: storage
    spec:
      securityContext:
        fsGroup: 1000
      containers:
      - name: minio
        image: minio/minio:RELEASE.2023-11-20T22-40-07Z
        ports:
        - containerPort: 9000
          name: api
        - containerPort: 9001
          name: console
        command:
        - /bin/bash
        - -c
        args:
        - |
          # Create data directory if it doesn't exist
          mkdir -p /data
          
          # Start MinIO server
          minio server /data --console-address ":9001"
        env:
        - name: MINIO_ROOT_USER
          valueFrom:
            secretKeyRef:
              name: storage-credentials
              key: s3-access-key
        - name: MINIO_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: storage-credentials
              key: s3-secret-key
        - name: MINIO_REGION
          valueFrom:
            secretKeyRef:
              name: storage-credentials
              key: s3-region
        - name: MINIO_BROWSER_REDIRECT_URL
          value: "http://192.168.49.2:30900"
        volumeMounts:
        - name: minio-storage
          mountPath: /data
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /minio/health/live
            port: 9000
          initialDelaySeconds: 60
          periodSeconds: 20
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /minio/health/ready
            port: 9000
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
      volumes:
      - name: minio-storage
        persistentVolumeClaim:
          claimName: minio-pvc
---
# MinIO Service
apiVersion: v1
kind: Service
metadata:
  name: minio-service
  namespace: production
  labels:
    app: minio
    component: storage
spec:
  type: ClusterIP
  selector:
    app: minio
  ports:
  - port: 9000
    targetPort: 9000
    name: api
  - port: 9001
    targetPort: 9001
    name: console
---
# MinIO NodePort Service for External Access
apiVersion: v1
kind: Service
metadata:
  name: minio-nodeport
  namespace: production
  labels:
    app: minio
    component: storage-external
spec:
  type: NodePort
  selector:
    app: minio
  ports:
  - port: 9000
    targetPort: 9000
    nodePort: 30900
    name: api
  - port: 9001
    targetPort: 9001
    nodePort: 30901
    name: console
---
# MinIO Bucket Initialization Job
apiVersion: batch/v1
kind: Job
metadata:
  name: minio-bucket-init
  namespace: production
  labels:
    app: minio-init
spec:
  # Allow up to 2 retries
  backoffLimit: 2
  # Overall job timeout of 20 minutes
  activeDeadlineSeconds: 1200
  template:
    metadata:
      labels:
        app: minio-init
    spec:
      restartPolicy: OnFailure
      initContainers:
      # Wait for MinIO to be ready with better timeout and error handling
      - name: wait-for-minio
        image: curlimages/curl:8.4.0
        command:
        - /bin/sh
        - -c
        - |
          echo "Waiting for MinIO to be ready..."
          attempt=0
          max_attempts=60  # 10 minutes with 10 second intervals
          
          while [ $attempt -lt $max_attempts ]; do
            if curl -f -m 5 http://minio-service:9000/minio/health/ready 2>/dev/null; then
              echo "MinIO is ready!"
              exit 0
            fi
            
            attempt=$((attempt + 1))
            echo "MinIO not ready yet (attempt $attempt/$max_attempts), waiting..."
            
            # Show more detailed status every 30 attempts (5 minutes)
            if [ $((attempt % 30)) -eq 0 ]; then
              echo "Extended wait - checking if MinIO service exists..."
              nslookup minio-service || echo "MinIO service DNS not ready"
            fi
            
            sleep 10
          done
          
          echo "ERROR: MinIO failed to become ready after $max_attempts attempts"
          echo "Trying direct connection test..."
          curl -v http://minio-service:9000/minio/health/ready || true
          exit 1
        resources:
          requests:
            memory: "32Mi"
            cpu: "25m"
          limits:
            memory: "64Mi"
            cpu: "100m"
      containers:
      - name: mc
        image: minio/mc:RELEASE.2023-11-20T16-30-59Z
        env:
        - name: MINIO_ROOT_USER
          valueFrom:
            secretKeyRef:
              name: storage-credentials
              key: s3-access-key
        - name: MINIO_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: storage-credentials
              key: s3-secret-key
        - name: S3_BUCKET
          valueFrom:
            secretKeyRef:
              name: storage-credentials
              key: s3-bucket
        command:
        - /bin/sh
        - -c
        - |
          echo "Configuring MinIO client..."
          
          # Configure mc client
          mc alias set minio http://minio-service:9000 $MINIO_ROOT_USER $MINIO_ROOT_PASSWORD
          
          # Check if bucket exists, create if not
          if ! mc ls minio/$S3_BUCKET > /dev/null 2>&1; then
            echo "Creating bucket: $S3_BUCKET"
            mc mb minio/$S3_BUCKET
            
            # Set bucket policy to allow read access for image serving
            cat > /tmp/policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "AWS": ["*"]
                },
                "Action": ["s3:GetObject"],
                "Resource": ["arn:aws:s3:::$S3_BUCKET/public/*"]
              }
            ]
          }
          EOF
            
            mc policy set-json /tmp/policy.json minio/$S3_BUCKET
            echo "Bucket $S3_BUCKET created and configured successfully"
          else
            echo "Bucket $S3_BUCKET already exists"
          fi
          
          # Create test directories
          echo "Creating directory structure..."
          echo "Test file" | mc pipe minio/$S3_BUCKET/uploads/.keep
          echo "Test file" | mc pipe minio/$S3_BUCKET/public/.keep
          echo "Test file" | mc pipe minio/$S3_BUCKET/processed/.keep
          
          # Upload a test image
          echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==" | base64 -d | mc pipe minio/$S3_BUCKET/public/test-image.png
          
          echo "MinIO initialization completed successfully"
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
---
# MinIO Prometheus ServiceMonitor
apiVersion: v1
kind: ConfigMap
metadata:
  name: minio-prometheus-config
  namespace: production
data:
  prometheus.yaml: |
    global:
      scrape_interval: 15s
    scrape_configs:
    - job_name: 'minio-job'
      bearer_token: 'your-prometheus-token'
      metrics_path: /minio/v2/metrics/cluster
      scheme: http
      static_configs:
      - targets: ['minio-service:9000']